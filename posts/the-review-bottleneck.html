<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Review Bottleneck: Why Software Engineering Isn't Ready for the AI Era - Tonderai Saidi</title>
    <link rel="stylesheet" href="../style.css">
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <header>
        <nav>
            <div class="nav-container">
                <h1 class="logo">Tonderai Saidi</h1>
                <ul class="nav-links">
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../blog.html">Blog</a></li>
                </ul>
            </div>
        </nav>
    </header>

    <main>
        <article class="post-content">
            <h1 class="post-title">The Review Bottleneck: Why Software Engineering Isn't Ready for the AI Era</h1>
            <p class="post-meta">February 10, 2026 Â· Reflections from a "Developer of Software"</p>

            <p>Software Engineering has been a passion of mine for a long time. It didn't start with binary or complex algorithms; it started with the joy of pure creation.</p>

            <p>My first introduction was <strong>Scratch</strong>. As a child, I didn't care about memory management or syntax errors; I loved that I could drag a block and make a cat dance. It was visual, immediate, and it hooked me on the feeling of building things.</p>

            <p>As I matured, I moved to Python, JavaScript, and eventually Java. I remember opening NetBeans for the first time and feeling a distinct shift. I was shocked by how much "static" was required just to get going. <code>public static void main</code>, imports, class definitions&mdash;we called it <em>boilerplate</em>. At the time, it felt like a heavy tax I had to pay just to get to the logic. But I paid it, because I loved the problem-solving. I loved controlling what happened between the curly brackets.</p>

            <p>When I got stuck in a <code>while</code> loop or hit a logic error, I didn't have an AI to fix it. I had <code>System.out.println</code> statements and sheer stubbornness. I would brute-force my way to a solution, learning the intricate behaviors of the code by breaking it and fixing it, line by line.</p>

            <h3>The Shift to "Bespoke Libraries"</h3>

            <p>Fast forward to 2026. I am working on a personal project&mdash;a complex application I've wanted to build for years. In the past, this would have taken me months of weekends.</p>

            <p>Today, I described the architecture to a multi-agent AI system. In minutes, it generated the file readers, the sorting algorithms, and the third-party client connectors.</p>

            <p>This brings me to a realization: <strong>The profession is not ready for what is coming.</strong></p>

            <p>We have always used abstractions to move faster. We stopped writing sorting algorithms from scratch because we have standard libraries. But an AI agent is effectively a <strong>bespoke library</strong>. It is an infinite import where performance isn't defined by the code's efficiency alone, but by the quality of your prompt and the number of tokens you can afford.</p>

            <p>The "frustrating" parts of code&mdash;the boilerplate I used to wrestle with in NetBeans&mdash;are gone. The AI generates it, and with recent model improvements, it matches the documentation surprisingly well.</p>

            <h3>The New Bottleneck: The Review Gap</h3>

            <p>Here is the problem we aren't talking about: <strong>Code is shipping faster than human cognition can verify it.</strong></p>

            <p>In my personal project, the "writing" bottleneck is solved. But I have created a massive "reading" bottleneck. The AI can generate a Pull Request with five new features in the time it takes me to brew a coffee, but it still takes me hours to understand the implications of that code.</p>

            <p>We have automated the typing, but we cannot automate the comprehension.</p>

            <p>I recognize that AI hallucinates. To counter this, I use TDD (Test Driven Development) and multi-agent setups to get reliable results. But this shifts my role entirely. I am no longer just writing functions; I am auditing them.</p>

            <p>Human bandwidth is narrow. We are not great at thinking systemically or holding deep recursive stacks in our heads&mdash;that's why we used to add breakpoints and debug statements to our <em>own</em> code. Now, we have to apply that rigorous debugging mindset to code we didn't even write.</p>

            <h3>The "Developer of Software"</h3>

            <p>I sometimes distance myself from the title "Software Engineer" these days. I prefer <strong>"Developer of Software."</strong></p>

            <p>It feels more accurate. My value isn't in knowing how to read a file from scratch anymore. That knowledge has become the new boilerplate.</p>

            <p>My value&mdash;and the future of this profession&mdash;lies in what the AI cannot do:</p>

            <ol>
                <li><strong>Systemic Architecture:</strong> Understanding how the pieces fit together when the codebase grows exponentially fast.</li>
                <li><strong>Edge Cases:</strong> Anticipating the weird, one-in-a-million user behaviors that aren't in the training data.</li>
                <li><strong>Human Navigation:</strong> Collaborating with others to define <em>what</em> we are building, rather than getting lost in <em>how</em> to type it.</li>
            </ol>

            <p>We are moving toward a future where the code is almost complete before we sit down. The challenge isn't creating the software; it's surviving the review process.</p>

            <a href="../blog.html" class="back-link">&larr; Back to Blog</a>
        </article>
    </main>

    <footer>
        <p>&copy; 2026 Tassan Saidi</p>
    </footer>
</body>
</html>
